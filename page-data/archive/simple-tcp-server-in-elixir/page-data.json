{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/archive/simple-tcp-server-in-elixir/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Blog name here"}},"markdownRemark":{"id":"f34a1e74-5480-51e7-bf5e-49981c27e8a2","excerpt":"One of my favorite functional languages is Erlang. First created in 1986,\nErlang is a highly concurrent language with high fault tolerance. It a great\ntool to…","html":"<p>One of my favorite functional languages is Erlang. First created in 1986,\nErlang is a highly concurrent language with high fault tolerance. It a great\ntool to have for any programmer. That being said, Erlang definitely shows its\nage and is missing many features that modern day languages excel at.</p>\n<p>That’s where the Elixir project comes in. Elixir is a language built on the\nErlang VM, that keeps all of the amazing abilities of Erlang, but adds features like;\nfunctional meta-programming, polymorphism via Clojure-like protocols, and hashes\n(or maps as they’re called in other languages).</p>\n<p>Erlang is known for its server capabilities, and here I’m going to show just how\neasy it is to create a simple TCP server in Elixir.</p>\n<p>First we declare a name-space for our functions.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defmodule TCPServer do\nend</code></pre></div>\n<p>Then create a listen function that takes a port.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defmodule TCPServer\n  def listen(port) do\n  end\nend</code></pre></div>\n<p>Now we can fill in that method with some content. We will be using the\ngen_tcp module from Erlang. The way we call down to Erlang from Elixir is to\njust call the module as a atom.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def listen(port) do\n  tcp_options = [:list, {:packet, 0}, {:active, false}, {:reuseaddr, true}]\n\n  {:ok, l_socket} = :gen_tcp.listen(port, tcp_options)\n\n  do_listen(l_socket)\nend</code></pre></div>\n<p>The first line just declares some options for the <code class=\"language-text\">:gen_tcp.listen</code> method.\nThe second line assign the <code class=\"language-text\">l_socket</code> variable. Finally we call the unwritten\nmethod <code class=\"language-text\">do_listen</code> with our new <code class=\"language-text\">l_socket</code>. Lets write that.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defp do_listen(l_socket) do\n  {:ok, socket} = :gen_tcp.accept(l_socket)\n\n  spawn(fn() -> do_server(socket) end)\n\n  do_listen(l_socket)\nend</code></pre></div>\n<p>First we grab a real socket from our <code class=\"language-text\">l_socket</code> when someone connects. Then we\nspawn our server from that socket. Finally we loop back around a continue to\nlisten to that port. Finally lets write the meat of our TCP Server.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">defp do_server(socket) do\n  case :gen_tcp.recv(socket, 0) do\n\n    { :ok, data } ->\n      :gen_tcp.send(socket, data)\n      do_server(socket)\n\n    { :error, :closed } -> :ok\n  end\nend</code></pre></div>\n<p>We create a case statement around the data we receive from the socket. When they\npass us good data, we just echo it back to them, then continue to listen. When\nwe get the signal that they disconnected, we drop out of our loop and the thread\ndies.</p>\n<p>Thats it! The entire program is 20 lines long, and very readable. I will\ncontinue to update this blog with more complex examples of what you can do with\nElixir.</p>","frontmatter":{"title":"Simple TCP server in Elixir","date":"July 27, 2012","description":null}},"previous":{"fields":{"slug":"/archive/do-not-count-on-persistent-state/"},"frontmatter":{"title":"Do not count on persistent state"}},"next":{"fields":{"slug":"/archive/testing-elixir/"},"frontmatter":{"title":"Testing Elixir"}}},"pageContext":{"id":"f34a1e74-5480-51e7-bf5e-49981c27e8a2","previousPostId":"ab8871fe-4f7b-5f6d-a09a-f446d3fc3884","nextPostId":"8ff0e40c-467a-59c0-90f8-5e915964e858"}},
    "staticQueryHashes": ["2841359383","3257411868"]}