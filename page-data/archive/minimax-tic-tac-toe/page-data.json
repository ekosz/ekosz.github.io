{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/archive/minimax-tic-tac-toe/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Blog name here"}},"markdownRemark":{"id":"38ae9550-6f6d-5783-8dc5-92572756b134","excerpt":"I already implemented TicTacToe using heuristics, today I was given the task to\nreimplement my TicTacToe AI using the MiniMax algorithm. If you don’t already…","html":"<p>I already implemented TicTacToe using heuristics, today I was given the task to\nreimplement my TicTacToe AI using the MiniMax algorithm.</p>\n<p>If you don’t already know, MiniMax is an algorithm that can be used in two\nplayer games such as Chess, Checkers, or TicTacToe. Using a game tree the\nalgorithm tries to maximize rewards during your turn, and minimize rewards\nduring the opponents turn. Hence its name “Minimax”.</p>\n<p>There are two parts to the MiniMax algorithm: the evaluator and the game tree\nlogic.</p>\n<h3>Evaluator</h3>\n<p>The evaluator is custom to the each implantation of Minimax. Its job\nis to take a game state, and rank it. For TicTacToe its job is simple.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">You Won:   1\nYou Lost: -1\nCats:      0</code></pre></div>\n<p>The numbers aren’t important, as long as they are in ascending order of what\nyou want to happen. Each game will have their own evaluator. The more complex\nthe game, the more complex the evaluator will have to be.</p>\n<h3>The Game Tree</h3>\n<p>The other part of the Minimax algorithm is the game tree logic, which is the\nsame for all of its implementations.</p>\n<p>The basic pattern looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class GameTree\n  def initialze(game_state, player, whos_turn=nil)\n    @game_state, @player = game_state, player\n    @whos_turn = whos_turn || player\n  end\n\n  def best_move\n    children.max(&amp;:score).move\n  end\n\n  def score\n    return  1 if game_state.over? &amp;&amp; game_state.winner == player\n    return -1 if game_state.over? &amp;&amp; game_state.winner == @opponent\n    return  0 if game_state.over?\n\n    if whos_turn == player\n      children.map { |child| child.score }.max\n    else\n      children.map { |child| child.score }.min\n    end\n  end\n\n  def children\n    potential_moves.map { |move| GameTree.new(move, player, next_turn) }\n  end\n\n  # ...\nend</code></pre></div>","frontmatter":{"title":"Minimax tic tac toe","date":"July 11, 2012","description":null}},"previous":{"fields":{"slug":"/archive/chrome-web-store/"},"frontmatter":{"title":"Chrome web store"}},"next":{"fields":{"slug":"/archive/static-code-analysis/"},"frontmatter":{"title":"Static code analysis"}}},"pageContext":{"id":"38ae9550-6f6d-5783-8dc5-92572756b134","previousPostId":"225e4a59-0ccc-5b71-953d-1b8dee7ff367","nextPostId":"55c4a19a-3902-5433-bfc2-39eab365fa54"}},
    "staticQueryHashes": ["2841359383","3257411868"]}