{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/archive/chrome-web-store/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Blog name here"}},"markdownRemark":{"id":"225e4a59-0ccc-5b71-953d-1b8dee7ff367","excerpt":"Last week I launched Japanese Vocab Tutor mostly to be able to say I published an app. The actual application took about two days to create and style, and is a…","html":"<p>Last week I launched <a href=\"https://chrome.google.com/webstore/detail/ldemblkooloonmjfiainhkhmmlelfnfb\">Japanese Vocab Tutor</a> mostly to be able to say I published an app. The actual application took about two days to create and style, and is a pretty basic flash card application with some nice features. The real problem happened on the third day, hooking it up to the Google Licence API. This was a lot harder then I thought it would be.</p>\n<p>I used three tools to pull it off:</p>\n<ol>\n<li><a href=\"http://www.sinatrarb.com/\">Sinatra</a> - For running the show</li>\n<li><a href=\"https://github.com/josh/rack-openid\">Rack OpenID</a> - To grab the users Google OpenID ID (confusing I know)</li>\n<li><a href=\"http://signet.rubyforge.org/\">Signet Oauth Client</a> - To access the Google Licence API</li>\n</ol>\n<p>First require all of it</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require 'rubygems'\nrequire 'sinatra'\nrequire 'json'\nrequire 'signet/oauth_1/client'\nrequire 'rack/openid'\n\nuse Rack::Session::Cookie\nenable :sessions\nuse Rack::OpenID</code></pre></div>\n<p>Now for the fun stuff</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">get '/login' do\n    # Have provider identifier, tell rack-openid to start OpenID process\n    headers 'WWW-Authenticate' => Rack::OpenID.build_header(\n      :identifier => \"https://www.google.com/accounts/o8/id\",\n      :required => [\"http://specs.openid.net/auth/2.0/identifier_select\"],\n      :realm => \"&lt;YOURSITEHERE>\",\n      :return_to => url_for('/openid/complete'),\n      :method => 'post')\n    halt 401, 'Authentication required.'\nend\n\nget '/logout' do\n  session.clear\n  redirect '/'\nend\n\n# Handle the response from the OpenID provider\npost '/openid/complete' do\n  resp = request.env[\"rack.openid.response\"]\n  if resp.status == :success\n    client = Signet::OAuth1::Client.new(\n      :client_credential_key => consumer_key,\n      :client_credential_secret => consumer_secret,\n      :token_credential_key => oauth_token,\n      :token_credential_secret => oauth_token_secret\n    )\n    openid_uri = Signet::OAuth1.encode(resp.identity_url)\n    request_uri =  'https://www.googleapis.com/chromewebstore/v1/licenses/'+\n                    app_id+'/'+openid_uri\n    response = client.fetch_protected_resource( :uri => request_uri )\n\n    status, headers, body = response\n\n    session[:bought] = JSON.load(body[0])['accessLevel'] || 'NONE'\n\n    redirect '/'\n  else\n    \"Error: #{resp.status}\"\n  end\nend</code></pre></div>\n<p>###Login</p>\n<p>First off, your <code class=\"language-text\">/login</code> is where you send your users when you need to find\ntheir payment status. I have all of my users do this right from the start.\nThis method creates a page with a status code of <code class=\"language-text\">401</code> and a special header of\n<code class=\"language-text\">WWW-Authenticate</code>. When <code class=\"language-text\">Rack OpenID</code> sees this status code and the this\nheader, it automatically redirects to the proper OpenID provider, and provides the\ninformation needed.</p>\n<p>You provide the header with a hash consisting of:</p>\n<ol>\n<li><code class=\"language-text\">:identifier</code> - What OpenID provider to use, in this case we need Google.</li>\n<li><code class=\"language-text\">:required</code> - An array of urls that correlates to what parameters of the user\nyou want the OpenID provider to give you. In this case all we want in the\nusers Google OpenID ID. Google provides <a href=\"http://code.google.com/apis/accounts/docs/OpenID.html\">this page</a> for matching parameters to urls.</li>\n<li><code class=\"language-text\">:realm</code> - This is the website that you are asking users to trust, it should\nbe the exact same website that they are being returned to. The web store\nwill make sure that this is the same url that your application is located.</li>\n<li><code class=\"language-text\">:return_to</code> - Where to redirect the user after they sign in. I use\na helper method to generate the full url.</li>\n<li><code class=\"language-text\">:method</code> - How the user should be redirected back to your site, we want\npost in this case.</li>\n</ol>\n<p>###Callback</p>\n<p>Next we have the <code class=\"language-text\">post /openid/complete</code> pattern to fill out. This is where\nthe user is redirected after they sign in through OpenID. <code class=\"language-text\">Rack OpenID</code> makes\nanother appearance as it automatically recognizes OpenID responses, and stuffs the\ndata into an Environment Variable called <code class=\"language-text\">rack.openid.response</code>. You grab that\ndata, and check if the response is successful. If so, its time for some Oauth\nmagic.</p>\n<p>Things you will need for this part:</p>\n<ol>\n<li>Consumer Key and Consumer Secret - For all Web Store Oauth requests, these\nwill both be “anonymous”.</li>\n<li>Token Key and Token Secret - These can be generated at the Web Store\ndeveloper dashboard. <a href=\"http://code.google.com/chrome/webstore/docs/check_for_payment.html#token\">More Info Here</a>.</li>\n<li>App ID - This can be found in the url of your Web Store application.</li>\n</ol>\n<p>After generating the Oauth client object, you must encode the Google OpenID ID,\nfound the response’s <code class=\"language-text\">identity_url</code>, into something that Oauth can accept.\nNext you construct the Oauth <code class=\"language-text\">request url</code>, which is one part the Google Licence\nAPI url, one part <code class=\"language-text\">app id</code>, and one part encoded <code class=\"language-text\">identity_url</code>. Finally you\ncan send that off, and get your Oauth response.</p>\n<p>The response is made of three parts, <code class=\"language-text\">[status, headers, body]</code>. To make your\napplication more robust you can do some error checking here, but for me\nI skipped right into the heart of the matter, which was the body. The body is\nan array, with a JSON encoded response as the first element. This final\nresponse has a property of <code class=\"language-text\">accessLevel</code>, which according <a href=\"http://code.google.com/chrome/webstore/docs/check_for_payment.html#response\">to their\ndocumentation</a>\nwill either be <code class=\"language-text\">FULL</code>, <code class=\"language-text\">FREE_TRIAL</code>, or <code class=\"language-text\">NONE</code>. This is where I had my biggest\nissue, their documentation is WRONG, in the worst way. If a user has not\npurchased a copy, or installed a free trail, the <code class=\"language-text\">accessLevel</code> will not be\n<code class=\"language-text\">NONE</code>, it just won’t exist. I currently set a session variable with this data,\nbut you can do anything you want with it.</p>\n<p>And thats it. This took me about a day and a half, just to hunt through all of\nthe documentation, but now you don’t have to!</p>","frontmatter":{"title":"Chrome web store","date":"May 31, 2011","description":null}},"previous":{"fields":{"slug":"/archive/sinatra-vs-rails/"},"frontmatter":{"title":"Sinatra vs Rails"}},"next":{"fields":{"slug":"/archive/minimax-tic-tac-toe/"},"frontmatter":{"title":"Minimax tic tac toe"}}},"pageContext":{"id":"225e4a59-0ccc-5b71-953d-1b8dee7ff367","previousPostId":"cc3f657e-b4ed-575e-b2c5-58b929fe60e0","nextPostId":"38ae9550-6f6d-5783-8dc5-92572756b134"}},
    "staticQueryHashes": ["2841359383","3257411868"]}