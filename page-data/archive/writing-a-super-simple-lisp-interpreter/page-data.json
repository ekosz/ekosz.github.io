{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/archive/writing-a-super-simple-lisp-interpreter/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Blog name here"}},"markdownRemark":{"id":"db56a098-0f9f-5280-ae48-b77b709ffb5d","excerpt":"It seems that its every programmers right of passage to write their own lisp\ninterpreter. What most beginner programmers don’t realize is just how easy this…","html":"<p>It seems that its every programmers right of passage to write their own lisp\ninterpreter. What most beginner programmers don’t realize is just how easy this\nfeet can be. Here I’ll demonstrate how to create one of these interpreters in\nless than 100 LOC.</p>\n<h3>The lexer</h3>\n<p>First part of any interpreter is the lexer. The lexers job to is to read\na string and turn it into a stream of tokens for the next part of the\ninterpreter. This can be done in a simple Regex statement.</p>\n<p>Lets first write some tests to make sure that our lexer is working.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">assert</span></span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span>\n  fail <span class=\"token string-literal\"><span class=\"token string\">\"expected </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">a<span class=\"token punctuation\">.</span>inspect</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">, got </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">b<span class=\"token punctuation\">.</span>inspect</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span> <span class=\"token keyword\">unless</span> a <span class=\"token operator\">==</span> b\n<span class=\"token keyword\">end</span>\n\nassert<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string-literal\"><span class=\"token string\">\"1\"</span></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> lex<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"1\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string-literal\"><span class=\"token string\">\"1\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal\"><span class=\"token string\">\"abc\"</span></span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> lex<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"1 abc\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">%w[ ( 1 abc ) ]</span></span><span class=\"token punctuation\">,</span> lex<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(1 abc)\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">%w[ (= 2 ( + 1  1 ) ) ]</span></span><span class=\"token punctuation\">,</span> lex<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(= 2 (+ 1 1))\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Alright this should handle all of the use cases of our lexer. Now lets get\nsome of these tests passing.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">lex</span></span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span>\n  string<span class=\"token punctuation\">.</span>scan<span class=\"token punctuation\">(</span><span class=\"token regex-literal\"><span class=\"token regex\">/\\w+|[\\(\\)\\+=]/</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Thats all we need to get our tests passing. These regex tokenizes our string\nusing words, parentheses, plus signs and equal signs.</p>\n<p>Now that the lexer is written we can write our parser. The parser takes in the\ntoken from our lexer, and turns them into s-expressions that our interpretor\ncan use. Lets write some tests for our parser.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">assert<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> parse<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"1\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token symbol\">:abc</span><span class=\"token punctuation\">,</span> parse<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"abc\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> parse<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(1)\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token symbol\">:\"=\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">:</span><span class=\"token operator\">+</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> parse<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(= 2 (+ 1 1))\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We want our parser to treat our numbers as numbers and everything else as\nsymbols. We also want it to create arrays as the s-expression forms.\nImplementing this it a bit more complicated but still reasonable.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Parser</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">initialize</span></span><span class=\"token punctuation\">(</span>tokens<span class=\"token punctuation\">)</span>\n    <span class=\"token variable\">@tokens</span> <span class=\"token operator\">=</span> tokens\n    <span class=\"token variable\">@pos</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">parse</span></span>\n    t <span class=\"token operator\">=</span> next_token\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">if</span> t <span class=\"token operator\">==</span> <span class=\"token string-literal\"><span class=\"token string\">\")\"</span></span>\n\n    <span class=\"token keyword\">if</span> t <span class=\"token operator\">==</span> <span class=\"token string-literal\"><span class=\"token string\">\"(\"</span></span>\n      array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>parsed <span class=\"token operator\">=</span> parse<span class=\"token punctuation\">)</span>\n        array <span class=\"token operator\">&lt;&lt;</span> parsed\n      <span class=\"token keyword\">end</span>\n      <span class=\"token keyword\">return</span> array\n    <span class=\"token keyword\">end</span>\n\n    <span class=\"token builtin\">Integer</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token keyword\">rescue</span> t<span class=\"token punctuation\">.</span>to_sym\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">private</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">next_token</span></span>\n    <span class=\"token variable\">@tokens</span><span class=\"token punctuation\">[</span><span class=\"token variable\">@pos</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>tap <span class=\"token punctuation\">{</span> <span class=\"token variable\">@pos</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">parse</span></span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span>\n  <span class=\"token class-name\">Parser</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>lex<span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>parse\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>The parser iterates over the tokens. When it finds a open parenthesis, it\nstarts up a array and starts shovelling parsed tokens into it until it finds\na closing parenthesis. Otherwise it tries to convert the token into an\nInteger. Failing that it turns the token into a symbol.</p>\n<p>Now that our string has been lexed, then parsed into s-expressions we can\nfinally interpret the results. Interpreters can get as complicated as you\nwant, but for our purposes we’re only going to support adding and comparing.\nAgain we’re going to start with our tests.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">assert<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lisp<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"1\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> lisp<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(+ 1 1)\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> lisp<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(= 2 (+ 1 1))\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nassert<span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> lisp<span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"(= 3 (+ 1 1))\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>And for the interpreter itself.</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Interpreter</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">initialize</span></span><span class=\"token punctuation\">(</span>expressions<span class=\"token punctuation\">)</span>\n    <span class=\"token variable\">@expressions</span> <span class=\"token operator\">=</span> expressions\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">interpret</span></span><span class=\"token punctuation\">(</span>expression <span class=\"token operator\">=</span> <span class=\"token variable\">@expressions</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> expression<span class=\"token punctuation\">.</span>is_a<span class=\"token operator\">?</span> <span class=\"token builtin\">Array</span>\n      command <span class=\"token operator\">=</span> expression<span class=\"token punctuation\">.</span>first\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">case</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span>\n             <span class=\"token keyword\">when</span> <span class=\"token operator\">:</span><span class=\"token operator\">+</span>\n               interpret<span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> interpret<span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n             <span class=\"token keyword\">when</span> <span class=\"token operator\">:</span><span class=\"token operator\">=</span>\n               interpret<span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> interpret<span class=\"token punctuation\">(</span>expression<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n             <span class=\"token keyword\">else</span>\n               <span class=\"token keyword\">raise</span> <span class=\"token string-literal\"><span class=\"token string\">\"Unknown command: </span><span class=\"token interpolation\"><span class=\"token delimiter punctuation\">#{</span><span class=\"token content\">command<span class=\"token punctuation\">.</span>to_s</span><span class=\"token delimiter punctuation\">}</span></span><span class=\"token string\">\"</span></span>\n             <span class=\"token keyword\">end</span>\n     <span class=\"token keyword\">end</span>\n\n     expression\n  <span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">lisp</span></span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span>\n  <span class=\"token class-name\">Interpreter</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>parse<span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>interpret\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>This interpreter has no idea of variables or state, but it works for our\npurposes. From here we’d implement tracking the current environment and\nremoving the hard coded functions.</p>","frontmatter":{"title":"Writing a super simple lisp interpreter","date":"October 16, 2012","description":null}},"previous":{"fields":{"slug":"/archive/test-driven-clojure-part-six/"},"frontmatter":{"title":"Test driven Clojure part VI"}},"next":{"fields":{"slug":"/archive/looking-the-part/"},"frontmatter":{"title":"Looking the part"}}},"pageContext":{"id":"db56a098-0f9f-5280-ae48-b77b709ffb5d","previousPostId":"83fd09d7-7858-528f-8b60-78f6d3ff48c9","nextPostId":"273d304d-b278-5ebd-9451-b91dea853bb6"}},
    "staticQueryHashes": ["2841359383","3257411868"]}